<p>
    Implement a GPU program that computes the Rotary Positional Embedding (RoPE) for a batch of query vectors.
    RoPE is a method for encoding positional information in transformer models by rotating the query and key vectors using precomputed cosine and sine components.
</p>
<p>
    Mathematically, given a query vector \(x\) and corresponding cosine and sine vectors, the operation is defined as:
    \[
    \text{RoPE}(x) = x \odot \cos + \text{rotate\_half}(x) \odot \sin
    \]
</p>
<p>
    Where \(\odot\) denotes element-wise multiplication. The \(\text{rotate\_half}(x)\) operation swaps the first and second halves of the vector and negates the first half. For a vector of dimension \(d\):
    \[
    \text{rotate\_half}([x_1, \dots, x_{d/2}, x_{d/2+1}, \dots, x_d]) = [-x_{d/2+1}, \dots, -x_d, x_1, \dots, x_{d/2}]
    \]
</p>
<h2>Implementation Requirements</h2>
<ul>
    <li>External libraries are not permitted</li>
    <li>The <code>solve</code> function signature must remain unchanged</li>
    <li>The input tensors <code>Q</code>, <code>cos</code>, and <code>sin</code> have shape <code>(M, D)</code>, where <code>M</code> is the number of tokens and <code>D</code> is the head dimension</li>
    <li><code>D</code> (head dimension) is guaranteed to be an even number</li>
    <li>The final result must be stored in the output variable with the same shape <code>(M, D)</code></li>
</ul>
<h2>Example 1:</h2>
<pre>Input:  Q   = [[1.0, 2.0, 3.0, 4.0],
               [1.0, 1.0, 1.0, 1.0]]
        Cos = [[1.0, 1.0, 1.0, 1.0],
               [0.0, 0.0, 0.0, 0.0]]
        Sin = [[0.0, 0.0, 0.0, 0.0],
               [1.0, 1.0, 1.0, 1.0]]
Output: result = [[1.0, 2.0, 3.0, 4.0],
                  [-1.0, -1.0, 1.0, 1.0]]
        (Row 0 is identity via Cos; Row 1 is rotated via Sin)</pre>
<h2>Constraints</h2>
<ul>
    <li><code>Q</code>, <code>cos</code>, and <code>sin</code> have identical dimensions</li>
    <li><code>D</code> % 2 == 0</li>
    <li>1 ≤ <code>M</code>, <code>D</code> ≤ 10,000</li>
</ul>
